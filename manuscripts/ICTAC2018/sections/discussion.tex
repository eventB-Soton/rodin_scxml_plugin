% !TEX root = ../SCXMLREF.tex

\section{Discussion}
\label{sec:discussion}

%This is the discussion...
%Compare the behaviour of a visually similar statechart (SecBot?) in \iUMLB and \SCXML 
%	Based on their \EventB translations
%	Using the theorem prover to test whether they are equivalent (they are not)
%	Using the model checker to compare traces
%	Using LTL to show that certain temporal properties are not achieved by the \iUMLB version.
%
%
%Early attempts – 
%1)	Simple next step – based on negated guards – negation is weakened
%2)	Engine – improves the R2C semantics but still suffers from the negated guards problem (refinement of the user model kinda works – simulations at the user level).
%\ColinCommented{IF POSSIBLE? use the secbot example to illustrate the problem of guard stengthening on refinement}
%
%The solution:
%3)	Transition combinations approach – works because there is always one event to completion. Invariants as well as simulations. 
%a.	Explosion – mitigated by mutual exclusions… same trigger – different state-chart regions.
%
%What can we do with it? 
%	Why is RTC needed?
%	Refinement in RTC


In order to introduce a notion of refinement into \SCXML we need to consider the kinds of things we would like to do in refinements and what properties should be preserved.
In practice we wish to leverage existing \EventB verification tools and hence adopt a notion of refinement that can be automatically translated into an equivalent \EventB model consisting of a chain of refinements. While it might be possible to utilise data refinement by replacing a state-chart with an alternative one, this would greatly complicate things and is impractical when the \SCXML model is a single state-chart (rather than a chain of refined models). Hence we start from the following requirements which allow superposition refinements and guard strengthening in \SCXML models:
\begin{itemize}
	\item The firing conditions of a transition can be strengthened by adding further textual constraints about the state of other variables and statemachines in the system.
	\item The firing conditions of a transition can be strengthened by being more specific about the (nested) source state,
	\item Nested state-charts can be added in refinements.
	\item Ancilliary data can be added and corresponding actions to alter it added to transitions.
	\item Raise actions can be added to transitions to define how internal triggers are raised. These internal triggers may have already been introduced and used to trigger transitions in which case they are non-deterministically raised at the abstract levels. (Note that external triggers are always unguarded and cannot be refined).
	\item Invariants can be added to states to specify properties that hold while in that state.
\end{itemize}

Refinement should preserve the value of the abstract state after each micro-step and at the end of each macro-step. The abstract state should not be altered by any new micro-steps that are introduced into an abstract macro-step, nor by any new macro-steps that are introduced. (Note that these goals take the view that macro-steps should align through refinement. An alternative approach that we are considering for future work takes the view that the macro-steps need not align and a micro-step may shift from one macro-step to another in a refinement). 

There seems to be an inherent difficulty with refining `run to completion' semantics which require that every enabled micro step, is completed before the next macro step is started. The problem is that, in a refinement, we want to strengthen the conditions for a micro step. However, by making the micro steps more constrained we disable them and make their completion more easily achieved. This makes the guard for taking the next macro step weaker breaking the notion of refinement.




