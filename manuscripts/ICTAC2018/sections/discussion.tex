% !TEX root = ../SCXMLREF.tex

\section{Discussion}
\label{sec:discussion}

%This is the discussion...
%Compare the behaviour of a visually similar statechart (SecBot?) in \iUMLB and \SCXML 
%	Based on their \EventB translations
%	Using the theorem prover to test whether they are equivalent (they are not)
%	Using the model checker to compare traces
%	Using LTL to show that certain temporal properties are not achieved by the \iUMLB version.
%
%
%Early attempts – 
%1)	Simple next step – based on negated guards – negation is weakened
%2)	Engine – improves the R2C semantics but still suffers from the negated guards problem (refinement of the user model kinda works – simulations at the user level).
%\ColinCommented{IF POSSIBLE? use the secbot example to illustrate the problem of guard stengthening on refinement}
%
%The solution:
%3)	Transition combinations approach – works because there is always one event to completion. Invariants as well as simulations. 
%a.	Explosion – mitigated by mutual exclusions… same trigger – different state-chart regions.
%
%What can we do with it? 
%	Why is RTC needed?
%	Refinement in RTC


In order to introduce a notion of refinement into \SCXML we need to consider the kinds of things we would like to do in refinements and what properties should be preserved.
In practice we wish to leverage existing \EventB verification tools and hence adopt a notion of refinement that can be automatically translated into an equivalent \EventB model consisting of a chain of refinements. While it might be possible to utilise data refinement by replacing a state-chart with an alternative one, this would greatly complicate things and is impractical when the \SCXML model is a single state-chart (rather than a chain of refined models). Hence we start from the following requirements which allow superposition refinements and guard strengthening in \SCXML models:
\begin{itemize}
	\item The firing conditions of a transition can be strengthened by adding further textual constraints about the state of other variables and statemachines in the system.
	\item The firing conditions of a transition can be strengthened by being more specific about the (nested) source state,
	\item Nested state-charts can be added in refinements.
	\item Ancilliary data can be added and corresponding actions to alter it added to transitions.
	\item Raise actions can be added to transitions to define how internal triggers are raised. These internal triggers may have already been introduced and used to trigger transitions in which case they are non-deterministically raised at the abstract levels. (Note that external triggers are always unguarded and cannot be refined).
	\item Invariants can be added to states to specify properties that hold while in that state.
\end{itemize}

Refinement should preserve the value of the abstract state after each micro-step and at the end of each macro-step. The abstract state should not be altered by any new micro-steps that are introduced into an abstract macro-step, nor by any new macro-steps that are introduced. (Note that these goals take the view that macro-steps should align through refinement. An alternative approach that we are considering for future work takes the view that the macro-steps need not align and a micro-step may shift from one macro-step to another in a refinement). 

There seems to be an inherent difficulty with refining `run to completion' semantics which require that every enabled micro step, is completed before the next macro step is started. The problem is that, in a refinement, we want to strengthen the conditions for a micro step. However, by making the micro steps more constrained we disable them and make their completion more easily achieved. This makes the guard for taking the next macro step weaker breaking the notion of refinement.

\KarlaCommented{Starting to include the basis and related discussion maybe it should a a subsection}

\begin{EventBcode}
	CONTEXT
		basis 	// (generated for SCXML)
	SETS
	⚬	SCXML_TRIGGER	 // all possible triggers
	CONSTANTS
	⚬	SCXML_FutureInternalTrigger	 // all possible internal triggers
	⚬	SCXML_FutureExternalTrigger	 // all possible external triggers
	AXIOMS
	⚬	axm1:	partition(SCXML_TRIGGER,SCXML_FutureInternalTrigger,SCXML_FutureExternalTrigger) not theorem 
	END
\end{EventBcode}

\begin{EventBcode}
MACHINE
		basis 	// (generated for SCXML)
	SEES
	⚬	 basis 
	VARIABLES
	⚬	SCXML_iq	 // internal trigger queue
	⚬	SCXML_eq	 // external trigger queue
	⚬	SCXML_uc	 // run to completion flag
	INVARIANTS
	⚬	typeof_SCXML_iq:	SCXML_iq ⊆ SCXML_FutureInternalTrigger not theorem // internal trigger queue
	⚬	typeof_SCXML_eq:	SCXML_eq ⊆ SCXML_FutureExternalTrigger not theorem // external trigger queue
	⚬	disjointQueues:	SCXML_iq ∩ SCXML_eq= ∅ not theorem queues are disjoint
	⚬	typeof_SCXML_uc:	SCXML_uc ∈ BOOL not theorem completion flag
	EVENTS
	⚬	INITIALISATION:	 not extended ordinary 
		THEN
		⚬	init_SCXML_iq:	SCXML_iq ≔ ∅ // internal Q is initially empty
		⚬	init_SCXML_eq:	SCXML_eq ≔ ∅ // external Q is initially empty
		⚬	init_SCXML_uc:	SCXML_uc ≔ FALSE // completion is initially FALSE
		END

	⚬	SCXML_futureExternalTrigger:	 not extended ordinary 
		ANY
		⚬	SCXML_raisedTriggers	 
		WHERE
		⚬	typeof_SCXML_raisedTriggers:	SCXML_raisedTriggers ⊆ SCXML_FutureExternalTrigger not theorem 
		THEN
		⚬	SCXML_raiseExternalTriggers:	SCXML_eq ≔ SCXML_eq ∪ SCXML_raisedTriggers 
		END

	⚬	SCXML_futureExternalTransitionSet:	 not extended ordinary 
		ANY
		⚬	SCXML_et	 
		⚬	SCXML_raisedTriggers	 
		WHERE
		⚬	typeof_SCXML_et:	SCXML_et ∈ SCXML_eq not theorem 
		⚬	SCXML_internalQEmpty:	SCXML_iq = ∅ not theorem 
		⚬	SCXML_isComplete:	SCXML_uc = TRUE not theorem 
		⚬	typeof_SCXML_raisedTriggers:	SCXML_raisedTriggers ⊆ SCXML_FutureInternalTrigger not theorem 
		THEN
		⚬	SCXML_notComplete:	SCXML_uc ≔ FALSE 
		⚬	SCXML_consumeExternalTrigger:	SCXML_eq ≔ SCXML_eq ∖ {SCXML_et} 
		⚬	SCXML_raiseInternalTriggers:	SCXML_iq ≔ SCXML_iq ∪ SCXML_raisedTriggers 
		END

	⚬	SCXML_futureInternalTransitionSet:	 not extended ordinary 
		ANY
		⚬	SCXML_it	 
		⚬	SCXML_raisedTriggers	 
		WHERE
		⚬	typeof_SCXML_it:	SCXML_it  ∈ SCXML_iq not theorem 
		⚬	SCXML_isComplete:	SCXML_uc = TRUE not theorem 
		⚬	typeof_SCXML_raisedTriggers:	SCXML_raisedTriggers ⊆ SCXML_FutureInternalTrigger not theorem 
		THEN
		⚬	SCXML_notComplete:	SCXML_uc ≔ FALSE 
		⚬	SCXML_consumeInternalTrigger:	SCXML_iq ≔ (SCXML_iq ∪ SCXML_raisedTriggers) ∖ {SCXML_it} 
		END

	⚬	SCXML_futureUntriggeredTransitionSet:	 not extended ordinary 
		ANY
		⚬	SCXML_raisedTriggers	 
		WHERE
		⚬	SCXML_isNotComplete:	SCXML_uc = FALSE not theorem 
		⚬	typeof_SCXML_raisedTriggers:	SCXML_raisedTriggers ⊆ SCXML_FutureInternalTrigger not theorem 
		THEN
		⚬	SCXML_NotComplete:	SCXML_uc ≔ FALSE 
		⚬	SCXML_raiseInternalTriggers:	SCXML_iq ≔ SCXML_iq ∪ SCXML_raisedTriggers 
		END

	⚬	SCXML_Completion:	 not extended ordinary 
		WHERE
		⚬	SCXML_isNotComplete:	SCXML_uc = FALSE not theorem 
		THEN
		⚬	SCXML_Complete:	SCXML_uc ≔ TRUE 
		END

	END
\end{EventBcode}




\ColinCommented{Here we should discuss the various translations that we have tried illustrating the problems of getting a refinment. Mainly the idea of having a scheduling engine that moves the transition guards to a scheduler and fires a collection of enabled transitions before moving to the next step, versus the flattened
combinations approach that we finally adopted.}


